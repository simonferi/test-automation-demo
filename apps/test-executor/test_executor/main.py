"""CLI entrypoint for the unified smoke runtime."""

from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path
from typing import Optional
import sys

import typer

if __package__ in {None, ""}:
    sys.path.append(str(Path(__file__).resolve().parents[1]))
    __package__ = "test_executor"

from .output_config import get_output_format, OutputFormat, ENV_VAR_NAME
from .runner import ScenarioRunner

app = typer.Typer(help="Execute generated smoke scenarios and record artifacts.", invoke_without_command=True)

DEFAULT_OUTPUT = Path("runs")


@app.callback()
def run(
    bundle: Path = typer.Option(
        ...,
        exists=True,
        readable=True,
        help="Path to scenario directory or scenario.yaml file generated by cli-test-generator.",
    ),
    output_dir: Path = typer.Option(
        DEFAULT_OUTPUT,
        help="Directory where runtime artifacts (events, summary, junit) will be stored.",
    ),
    run_id: Optional[str] = typer.Option(
        None,
        help="Optional run identifier; defaults to scenario_id + timestamp.",
    ),
    output_format: str = typer.Option(
        None,
        help=f"Console output format: 'auto', 'rich', 'plain', 'json'. Env: {ENV_VAR_NAME}. Default: auto",
    ),
) -> None:
    """Execute the provided scenario bundle and emit structured outputs."""

    resolved_bundle = bundle if bundle.is_dir() else bundle.parent
    scenario_file = bundle if bundle.is_file() else resolved_bundle / "scenario.yaml"
    if not scenario_file.exists():
        raise typer.BadParameter(f"Scenario file not found under {bundle}")

    scenario_data = scenario_file.read_text(encoding="utf-8")
    scenario_id = _extract_scenario_id(scenario_data)
    effective_run_id = run_id or _default_run_id(scenario_id)
    
    # Get output format with priority: CLI > ENV > default
    output_fmt = get_output_format(output_format)

    runner = ScenarioRunner(
        bundle=bundle,
        output_root=output_dir,
        run_id=effective_run_id,
        output_format=output_fmt
    )
    summary = runner.run()
    
    # Exit with appropriate code
    if summary.failed_steps > 0:
        raise typer.Exit(1)


def _extract_scenario_id(raw_text: str) -> str:
    import yaml

    data = yaml.safe_load(raw_text)
    if isinstance(data, dict) and data.get("scenario_id"):
        return str(data["scenario_id"])
    return "scenario"


def _default_run_id(scenario_id: str) -> str:
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
    return f"{scenario_id}-{timestamp}"


def run_app() -> None:
    app()


if __name__ == "__main__":  # pragma: no cover
    run_app()
